name: PR自动检查与合并

# 权限配置
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  pr-check:
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 获取PR信息
        id: pr-info
        run: |
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "base_branch=${{ github.event.pull_request.base.ref }}" >> $GITHUB_OUTPUT
          echo "head_branch=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
          echo "pr_title=${{ github.event.pull_request.title }}" >> $GITHUB_OUTPUT

      - name: 检查文件变更
        id: check-files
        run: |
          # 获取变更的文件列表
          git fetch origin ${{ steps.pr-info.outputs.base_branch }}
          CHANGED_FILES=$(git diff --name-only origin/${{ steps.pr-info.outputs.base_branch }}...HEAD)
          echo "变更的文件："
          echo "$CHANGED_FILES"
          
          # 检查是否只有文档文件变更
          NON_DOC_FILES=$(echo "$CHANGED_FILES" | grep -v -E '\.(md|txt|rst|doc|docx|pdf)$' | grep -v '^docs/' | grep -v '^README' | grep -v '^CHANGELOG' | grep -v '^LICENSE' || true)
          
          if [ -z "$NON_DOC_FILES" ]; then
            echo "only_docs=true" >> $GITHUB_OUTPUT
            echo "检测到仅有文档文件变更"
          else
            echo "only_docs=false" >> $GITHUB_OUTPUT
            echo "检测到非文档文件变更："
            echo "$NON_DOC_FILES"
          fi

      - name: 设置Node.js环境
        if: steps.check-files.outputs.only_docs == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: '22.16.0'
          cache: 'npm'

      - name: 安装依赖
        if: steps.check-files.outputs.only_docs == 'false'
        run: |
          npm install
          cd client && npm install
          cd ../server && npm install

      - name: TypeScript类型检查
        if: steps.check-files.outputs.only_docs == 'false'
        id: type-check
        run: |
          echo "开始TypeScript类型检查..."
          
          # 检查server端
          echo "检查server端TypeScript..."
          cd server
          if npx tsc --noEmit; then
            echo "server_check=success" >> $GITHUB_OUTPUT
            echo "✅ Server端TypeScript检查通过"
          else
            echo "server_check=failed" >> $GITHUB_OUTPUT
            echo "❌ Server端TypeScript检查失败"
            exit 1
          fi
          
          cd ..
          
          # 检查client端
          echo "检查client端TypeScript..."
          cd client
          if npx tsc --noEmit; then
            echo "client_check=success" >> $GITHUB_OUTPUT
            echo "✅ Client端TypeScript检查通过"
          else
            echo "client_check=failed" >> $GITHUB_OUTPUT
            echo "❌ Client端TypeScript检查失败"
            exit 1
          fi
          
          echo "type_check_result=success" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: 处理TypeScript检查失败
        if: steps.check-files.outputs.only_docs == 'false' && steps.type-check.outputs.type_check_result != 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## ❌ TypeScript类型检查失败
            
            您的PR包含TypeScript类型错误，请修复后重新提交。
            
            ### 检查结果：
            - Server端检查：${{ steps.type-check.outputs.server_check == 'success' && '✅ 通过' || '❌ 失败' }}
            - Client端检查：${{ steps.type-check.outputs.client_check == 'success' && '✅ 通过' || '❌ 失败' }}
            
            请运行以下命令进行本地检查：
            \`\`\`bash
            # 检查server端
            cd server && npx tsc --noEmit
            
            # 检查client端  
            cd client && npx tsc --noEmit
            \`\`\`
            
            修复所有类型错误后，请重新推送代码。`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: 处理纯文档变更
        if: steps.check-files.outputs.only_docs == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## 📝 文档变更检测

            检测到您的PR仅包含文档文件变更，无需进行代码检查。

            此PR正在等待项目维护者的最终审核。感谢您对文档的贡献！ 🎉`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: 自动合并到feature分支
        if: steps.check-files.outputs.only_docs == 'false' && steps.type-check.outputs.type_check_result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.issue.number;
            const baseBranch = '${{ steps.pr-info.outputs.base_branch }}';
            const headBranch = '${{ steps.pr-info.outputs.head_branch }}';

            // 确定目标分支
            let targetBranch = 'feature';
            if (baseBranch === 'feature') {
              targetBranch = 'feature';
            } else if (baseBranch === 'main') {
              targetBranch = 'feature';
            }

            try {
              // 检查feature分支是否存在
              try {
                await github.rest.repos.getBranch({
                  owner,
                  repo,
                  branch: 'feature'
                });
              } catch (error) {
                if (error.status === 404) {
                  // 如果feature分支不存在，从main分支创建
                  const mainBranch = await github.rest.repos.getBranch({
                    owner,
                    repo,
                    branch: 'main'
                  });

                  await github.rest.git.createRef({
                    owner,
                    repo,
                    ref: 'refs/heads/feature',
                    sha: mainBranch.data.commit.sha
                  });

                  console.log('✅ 已创建feature分支');
                }
              }

              // 如果原目标是main分支，需要修改PR的目标分支为feature
              if (baseBranch === 'main') {
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: prNumber,
                  base: 'feature'
                });
                console.log('✅ 已将PR目标分支修改为feature');
              }

              // 合并PR到feature分支
              const mergeResult = await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                commit_title: `自动合并: ${{ steps.pr-info.outputs.pr_title }}`,
                commit_message: `通过自动化检查，合并到${targetBranch}分支进行测试`,
                merge_method: 'squash'
              });

              if (mergeResult.data.merged) {
                const comment = `## ✅ 自动化检查通过

                您的PR已通过所有自动化检查，已成功合并到 \`${targetBranch}\` 分支进行测试。

                ### 检查结果：
                - TypeScript类型检查：✅ 通过
                - Server端检查：✅ 通过
                - Client端检查：✅ 通过

                您的代码现在在专属测试分支中，项目维护者将进行最终检查。如果没有问题，将会合并到主分支并在下个版本发布时加入。

                感谢您的贡献！ 🎉`;

                await github.rest.issues.createComment({
                  issue_number: prNumber,
                  owner,
                  repo,
                  body: comment
                });

                console.log('✅ PR已成功合并到feature分支');
              }

            } catch (error) {
              console.error('合并过程中出现错误:', error);

              const errorComment = `## ⚠️ 自动合并失败

              虽然代码检查通过，但自动合并过程中遇到问题。可能的原因：
              - 存在合并冲突
              - 分支保护规则限制
              - 权限不足

              请联系项目维护者手动处理此PR。

              错误信息：\`${error.message}\``;

              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner,
                repo,
                body: errorComment
              });
            }
